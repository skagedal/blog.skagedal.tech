---
layout: post
title: "On JSX and more"
summary: "Starting from Dan Abrabmov's post"
---

I really enjoyed [this post](https://overreacted.io/jsx-over-the-wire/) by Dan Abramov, discussing the architecture of a modern web application. If you know who Dan Abramov is, you will probably anticipate where this all ends up – he is of course talking about React Server Ccomponents. But actually, I find the blog post worthy of a read even if you're not into RSC, as it takes us on a brief history of the web up until now. You may then actually stop the bus at any point along the route.

Consider reading Dan Abramov's post before continuing reading this one.

JSX is two things: a document model and a language.

### Mixing code and markup: PHP
One question here is about how to mix code and markup. There have been various approaches to this over the years, and one of the early successes was PHP. I was never a fan of PHP the programming language, but it got a lot of things right. It used to be the most accessible ways to get some code into your HTML, as many of the early "web hotels" supported it out the box. And  I guess it has modernized quite a bit since I last used it and I’m sure you can be very happy and productive using PHP.

```php
<h2>Links</h2>
<ul>
  <?php
    $links = array(
      "Insects" => "https://ournewinsectoverlords.com",
      "Home page" => "https://skagedal.tech" 
    );
    
    foreach($posts as $key => $value) { 
      echo "<li><a href=\"$value\">$key</a></li>\n"; 
    }
  ?>
</ul>
```

### Mixing code and markup: template language
I'm doing many of the things mentioned in Dan's post. At work, but also in some personal projects. Right now I'm working on both some some personal projects and one together with a friend. For my personal project, I have been going towards the back to basics approach where you generate HTML from the server. I write this application in Java, because I feel really productive in Java and I actually like how the programming environment "IntellIJ + Java" works.

But the question is how do I generate that HTML? There are a number of approaches. One is using a template language. I have been working on rewriting this very blog in Java. It’s currently implemented using Jekyll, a server static site generation blogging framework. The way it’s solved there with a template language Liquid.

```html
<h2>Posts</h2>
<ul>
  {% for post in site.posts %}
    <li>
      <a href="{{ post.url | prepend: site.baseurl }}">{{ post.title }}</a>
    </li>
  {% endfor %}
</ul>
```

I find this approach to work quite well for many tasks. I like to be able to just copy HTML from whatever sample I find on the web and use it directly. And transferring the site from the Ruby Jekyll script into a Java app turned out to be very easy. There were, of course, ready-made liquid processors for Java, which I could use and quickly get basically everything working – including an RSS feed, which was also built using a Liquid template. Very cool.

There is a variety of these template languages that are similar, but popular within different programming communities. Jekyll uses Liquid because that was popular in the Ruby world, in Python the equivalent thing is Jinja2. In the Java world, Thymeleaf seems to be the popular option.

But once to go into a fully programmatic world it starts to get a bit silly with these template languages. There’s always a point with this kind of template from work where I scream to the computer, I already have a programming language! Why do I need to trawl through documentation to do the most basic things like writing a for loop or traversing the object graph? What if I want something to be lazy evaluated rather than injected into some big context object? These are things I already know how to do in my programming language.

Another problem with the approach of mixing HTML-as-text with code, shared by both the PHP and the templating approaches discussed above, is that you get no guarantees of validity. The IDE can't help you make sure that your closing tags are matching and you open yourself up to injection problems.

So what do you do then? One approach is to just rely less on the templating language for the flow of control and basically just use it as a string replacer. At that point, you could just skip any thirdy-party templating language and use the ones shipped with the programming language:

```java
public class Renderer { 
  public String render(List<Link> links) {  
    return """
      <h2>Posts</h2>
      <ul>
        %s
      </ul>
      """.formatted(links.stream()
        .map(this::renderLink)
        .collect(Collectors.joining()));
  }  
  
  private String renderLink(Link link) {  
    return """  
        <li>
          <a href="%s">%s</a>
        </li>
      """.formatted(link.url(), link.name());  
}}
```

(Yes, classic `printf` style templates is the best we've got in Java – we were [so close](https://mail.openjdk.org/pipermail/amber-spec-experts/2024-April/004106.html)[^1] though!) 

We used exactly this approach at work recently where we needed to generate a PDF report from the backend. This wasn't expected to be a huge thing, just needed to render a simple report. After investigating various PDF toolkits, we found that the simplest way was to just generate HTML and render it to PDF using the library [openhtmltopdf](https://github.com/danfickle/openhtmltopdf). We wrote a very small set of helper methods to generate HTML. Now, when anyone needs to do some modification to that report, all they need to know is Java and HTML – nothing else to learn[^2]. I believe it was the right approach for the use case.

### Mixing code and markup: host programming language builders

However, for any larger application, you would soon feel the pain of having to 
You could take the approach of fully generating your object model in the host programming language.


But for a larger application, you would soon feel the pain of this approach for the next kind of approach is to use some kind of HTML builder framework in Java. I’m not quite sure what you would use. I’m working on a different project with a friend which is written in Colton There we use a framework called Kotlin X.HTML call is really nice and flexible in the way it allows you to make custom DSL‘s and in this one each HTML element is wrapped onto a builder. It looks like this example.
However, I still feel that this approach gets awkward. If it doesn’t look nice to me in quotation marks, the vocabulary of HML is just intrinsically bound to the syntax and shapes of HTML, which feels familiar look for example at what we have to do to write a text note in Coland X.HTML.that +… And also Whenever I find some example on the web which I would like to translate or use, I know how to go through an extra translation layer. The tooling is not there to help me in the same way at it as it would be with just HML for example, I am more and more You sing AI like Claude and ChatGPT to generate UI code, which I find that I don’t care so much about the details of.

So that’s one thing I really like about modern JavaScript type script development world: GSX you get this things for free I mean you’re kind of get both of both of two worlds here you get the familiar syntax of HTML yes I know that JSX is not Precisely the same as HML and is definitely not the same as XML. It is its own dialect, but it is certainly the same SGML based Cynth it feels right and you can pretty much copy whatever HML you find into a GSX document.

In a fully server side generated Application like some of those hobby projects I described the benefits of using something like GSX stops there. There are probably frameworks that you can use in JavaScript where you write JSX that just generate HML directly on the back up if you do, however, need front and interactivity it opens up for so I’m very interesting possibilities like the ones described in Dan Abramov’s blog post sending the actual GSX notes over the wire so that of course is what react server components are doing while also surrendering them to HML on the backend and somehow reconciliation things on the front end what’s called hydration?
Will we ever be able to write GSX in Java code? You could imagine some kind of a pre-processing framework.

I actually really like SGML syntax as a structured generalized markup language, which is exactly what the acronym expands to nothing else. There was a time when people believe in using this kind of syntax for everything all kinds like a generic data language you know XML I am in agreement with Most of the rest of the world today that this was a mistake. It simply isn’t very nice to work with XML for configuration such as the poem.XML files you would use in maven projects. Why is this well it is a markup language. It is meant to be used for content. That is primarily text And some of that text. You want to mark with specific tags and attributes like saying that this piece of text should be in a section or a paragraph and so long


Now, interestingly a lot of that usage where you have primarily text with some markup has lost its popularity. The SGML syntax has lost its popularity for still being to verbose instead, markdown has become ubiquitous. I like markdown I’m writing marked them right now, but sometimes I miss the ability for custom grammar that or should I say custom vocabulary that SGML so easily extend to there have been times where I have considered That I would’ve preferred this blog to use SGML for example, what if I want to define some specific component that I want to use here and there like a sidebar or a call out markdown doesn’t easily extend in that way I’m slightly excited about MDX

But the XGML syntax seems to work Really well for description of user interface so we have to look into the physics of the syntax to understand why this is the case why one thing feels right sometimes, and not the other, so the distinguishing feature of the SGML syntax is how each tag is closed by a tag containing the same Information so if you have a section start a section and you have some content in there at the end, you close the section by again writing/section. Why is that good? It certainly isn’t needed for the parlor. We could’ve imagined the HTML language looking just like the Scotland X tax I wrote above is that just an nurture thing? If HML had been designed today, would it have looked something like this? It’s not the case that there weren’t already people doing that look at the text rendering system. That’s TEX dot or look at the type testing system in the NROFF neither of those use this kind of Repetitious closing tax.
The reason that SGML shows that way it’s because it helps the human sometimes you will look at a Jason document or some Java code or especially some JavaScript or type script code and ask to yourself this curly race. What is it actually closing? Is it the end of the floor loop or the function or the lambda or whatever? By building.I have seen C code. I think this was more of a thing back in the day where such curly braces would have a comment after them explaining what they were closing, and some programming languages would take the same approach us SGML us here and and the closing mark with a Something like four or whatever.endfoR.
My solution to that problem, one programming is generally to break things up into smaller pieces small smaller functions that describe what they’re doing. But it depends. If I have some code, that really is just building up a big data structure perhaps in the test suite I wouldn’t mind just a big old nested hierarchy.
It works out well for user interface scrolling down the text and seeing that and section mark helps you connect the higher together in a nice way and distinguishing between attributes and Elements. Also something that works really well for this kind of use case user interfaces and markup in the world of pure data like configuration that distinction is mostly just in a way in the way I think that was what a lot of people experienced with XML as a data language and less pointless Considerations of whether something should be an attribute or an element of its own not so Jason took over and it only had maps and race and preventatives and everyone was happy. Maps and lists and primitives.
So could we have GSX in Java? Apparently the blog posts tell us They already have this in PHP now with something called xhp.I believe that you can do this kind of thing in C-sharp with the link that’s LINQ mechanism. I think I read somewhere about Jeff GEP that would bring sorry that JEP that would bring Similar capabilities to Java, but that would be very far off in the future I believe

There was a short-lived thing thing called string templates in Java that could be used in this space not exactly like that, but it would solve some of these problems with interpolation. It was however abandoned.

I also find interesting about this GSX over the wire approach is how it could be used for non-HTML situations the most the most relevant one being mobile apps. As discussed in the post, this type of thing has been implemented in many ways by many different companies. I too have been working at a place where we implemented our own system where the backend special BFF like services would return custom component system, which would be rendered by native apps we had one render implemented for iOS and another for android.after a lot of work I think this ended up a pretty usable system. Certainly, you would feel limited as an iOS developer since you wouldn’t be able to do any fancy layout that you might have wanted to do with or layout or whatever but in the end when we didn’t need all that much fancy stuff And we could build almost anything we need it. This both replaced the need to implement each screen. let me start again. This system served two purposes to begin with. You didn’t have to implement each screen for both iOS and android if that was the problem to solve, you could also reach for something like flutter or React native but it also served the purpose of updating. You are dynamically from the backend, not having to ship a new client just to show a different telephone number in a certain place in the app as you would have done in some other, strictly native only apps, which I have also worked on

Just rendering HTML directly in a web view was frowned upon by mobile app, developers, and it still doesn’t give you the same flexibility when you need a really smooth native experience I think depends. I think this depends a lot on what type of app you are doing and what the usage patterns will be like. Will this be something that the user Useless every day do you need to make every transition perfect and integration with the native device flawless? If not, I think some apps should still consider shipping a web view at least for some functionality
But if you do need a SDUI style system, it’s an interesting approach to Start from what’s being described here and let the components describe themselves in GSXJSX as the ubiquitous view model language this could be done irrespective of react either on the back or front you can imagine a job at shipping JSX components and round them with iOS native code

Another contender for such a ubiquitous view model language is… HTML.just send HTML over the wire even for just smaller components. This is the approach taken by the HTMX library that’s also an interesting approach and something that I wish to explore further, but the trade-offs are a different set. You’re now tying yourself to a specific rendering technology with all the complexities of modern browsers, of course you can restrict yourself to a simple subset.

So what are my bottom line takeaways and recommendations here I’m not sure.

I tried to have keep it simple as a guiding principle in my software development work and I think you should use the solution the simplest solution that works for your use case and that makes you happy. This often means sending HTML over the wire for me in my personal projects What I think. But I think that us keep it simple Folkes should stay curious about seemingly complex solutions. There’s often a problem there that is being solved. If you look really hard an interesting problem I believe there is a set of applications where the approach taken by react server components fits just like a glove. Everything gets pre-render on the background you get HTML ready to be rendered on the front end and then where you need to have a smooth interactive client side it’s sort of translates naturally. I believe there’s a separate set of applications. Where are you? Actually don’t need any of This service stuff at all and a traditional SPA style JavaScript app written in react or something else is what you want and many things in between.

let’s keep exploring.

[^1]: I am looking forward to the next iteration of this. I actually love that they are taking it slowly. The string processor functionality thing was cool, but a bit clunky. I am very happy that they seem to have not been impressed by the feedback from people thinking they should have used `$`-syntax – it's _so_ not worth it to introduce another character that will have to be escaped when you already have one. Swift uses the backslash syntax and it works great. I'd be happy if Java also used the "specify rawness"-syntax.   
[^2]: Ok, allright then, _almost_ nothing – since this is a custom and rather basic HTML rendering engine, you might need to be aware of its limitations and quirks. But as long as you write simple HTML and use tables for layout like it's 1999, you're good to go. 